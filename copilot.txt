To maintain and display revision history of JSON configuration documents in a Java Spring Boot application using Oracle as the database, you need to design a system that tracks and stores changes over time. Here’s a step-by-step approach:

---

## 1. **Database Design**

### **Table for Configurations**

```sql
CREATE TABLE metric_config (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    config_name VARCHAR2(255) NOT NULL,
    current_revision NUMBER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Table for Revisions**

```sql
CREATE TABLE metric_config_revision (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_config_id NUMBER NOT NULL,
    revision_number NUMBER NOT NULL,
    config_json CLOB NOT NULL,
    changed_by VARCHAR2(255),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    change_summary CLOB,
    FOREIGN KEY (metric_config_id) REFERENCES metric_config(id)
);
-- Index for quick lookup
CREATE INDEX idx_metric_config_revision_config ON metric_config_revision(metric_config_id, revision_number DESC);
```

---

## 2. **Spring Boot Entity Models**

```java name=MetricConfig.java
@Entity
@Table(name = "metric_config")
public class MetricConfig {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String configName;
    private Integer currentRevision;
    private LocalDateTime createdAt;
    // getters and setters
}
```

```java name=MetricConfigRevision.java
@Entity
@Table(name = "metric_config_revision")
public class MetricConfigRevision {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "metric_config_id")
    private MetricConfig metricConfig;

    private Integer revisionNumber;

    @Lob
    private String configJson;

    private String changedBy;
    private LocalDateTime changedAt;

    @Lob
    private String changeSummary; // Optional: Store diff summary

    // getters and setters
}
```

---

## 3. **Repository Interfaces**

```java name=MetricConfigRepository.java
public interface MetricConfigRepository extends JpaRepository<MetricConfig, Long> {
    Optional<MetricConfig> findByConfigName(String configName);
}
```

```java name=MetricConfigRevisionRepository.java
public interface MetricConfigRevisionRepository extends JpaRepository<MetricConfigRevision, Long> {
    List<MetricConfigRevision> findByMetricConfigIdOrderByRevisionNumberDesc(Long metricConfigId);
}
```

---

## 4. **Service Logic**

- When a user updates the JSON config, fetch the last revision, compare the JSONs, and store the new revision with a diff summary.
- Store the full JSON (for audit), but also optionally compute a summary of changes (e.g., using a JSON diff library).

```java name=MetricConfigService.java
@Service
public class MetricConfigService {

    @Autowired
    private MetricConfigRepository configRepo;

    @Autowired
    private MetricConfigRevisionRepository revisionRepo;

    public void updateConfig(String configName, String newConfigJson, String changedBy) throws Exception {
        MetricConfig config = configRepo.findByConfigName(configName)
                .orElseGet(() -> {
                    MetricConfig nc = new MetricConfig();
                    nc.setConfigName(configName);
                    nc.setCurrentRevision(0);
                    nc.setCreatedAt(LocalDateTime.now());
                    return configRepo.save(nc);
                });

        // fetch current revision's JSON
        MetricConfigRevision lastRev = revisionRepo
            .findByMetricConfigIdOrderByRevisionNumberDesc(config.getId())
            .stream().findFirst().orElse(null);

        int nextRevision = (lastRev == null) ? 1 : lastRev.getRevisionNumber() + 1;
        String changeSummary = "";
        if (lastRev != null) {
            changeSummary = JsonDiffUtil.diff(lastRev.getConfigJson(), newConfigJson); // implement this!
        }

        MetricConfigRevision revision = new MetricConfigRevision();
        revision.setMetricConfig(config);
        revision.setRevisionNumber(nextRevision);
        revision.setConfigJson(newConfigJson);
        revision.setChangedBy(changedBy);
        revision.setChangedAt(LocalDateTime.now());
        revision.setChangeSummary(changeSummary);

        revisionRepo.save(revision);

        config.setCurrentRevision(nextRevision);
        configRepo.save(config);
    }

    public List<MetricConfigRevision> getRevisionHistory(Long configId) {
        return revisionRepo.findByMetricConfigIdOrderByRevisionNumberDesc(configId);
    }
}
```

---

## 5. **Comparing JSONs (Diff Summary)**

- Use a library like [Java JSON Patch](https://github.com/java-json-tools/json-patch) or [Jackson](https://github.com/FasterXML/jackson) to compare two JSONs and produce a summary.

```java name=JsonDiffUtil.java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.flipkart.zjsonpatch.JsonDiff;

public class JsonDiffUtil {
    private static final ObjectMapper mapper = new ObjectMapper();

    public static String diff(String oldJson, String newJson) throws Exception {
        JsonNode oldNode = mapper.readTree(oldJson);
        JsonNode newNode = mapper.readTree(newJson);
        JsonNode patch = JsonDiff.asJson(oldNode, newNode);
        return patch.toString(); // Or process to a more readable summary
    }
}
```

---

## 6. **Controller Endpoints**

- Create endpoints to update config and fetch revision history.

```java name=MetricConfigController.java
@RestController
@RequestMapping("/api/config")
public class MetricConfigController {

    @Autowired
    private MetricConfigService configService;

    @PostMapping("/{name}")
    public ResponseEntity<?> updateConfig(
            @PathVariable String name,
            @RequestBody String configJson,
            @RequestHeader("X-User") String user
    ) throws Exception {
        configService.updateConfig(name, configJson, user);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{id}/history")
    public List<MetricConfigRevision> getHistory(@PathVariable Long id) {
        return configService.getRevisionHistory(id);
    }
}
```

---

## 7. **UI Side**

- Display the list of revisions with who/when/what changed.
- Optionally show the diff summary for each revision (parsed from the `changeSummary` field).

---

## **Summary**

- Store each JSON config change as a new revision in a separate table.
- Store the diff summary between revisions for easy UI display.
- Fetch and display revision history from the DB.
- Use libraries to compute JSON diffs for audit trails.

Let me know if you need a full working sample or more details on any part!



# Solution Design Document: JSON Configuration Revision History System

## 1. **Overview**

The goal of this system is to maintain a revision history for JSON-based configuration documents in a Java Spring Boot application, using Oracle as the database. Users can update configuration documents via a UI, and all changes—including who made the change and when—are tracked. The system enables easy retrieval and auditing of configuration changes, supports rollback to earlier revisions, and provides change summaries for UI display.

---

## 2. **Architecture**

**Components:**
- **Frontend/UI:** Allows users to view and edit configuration JSONs and their revision history.
- **Backend (Spring Boot):**
  - REST APIs for CRUD operations on configurations and revisions.
  - Business logic for managing revisions, computing diffs, and auditing.
- **Database (Oracle):** Stores configuration documents and their history.

**Interaction Flow:**
1. User submits a new version of a configuration JSON via the UI.
2. Backend compares the new JSON with the latest revision, computes a diff, and stores a new revision entry with metadata.
3. UI can fetch the revision history and display diffs and metadata.

---

## 3. **Database Design**

### 3.1. `config` Table

| Field             | Type            | Description                        |
|-------------------|-----------------|------------------------------------|
| id (PK)           | NUMBER          | Unique config identifier           |
| name              | VARCHAR2(255)   | Config name (unique)               |
| current_revision  | NUMBER          | Latest revision number             |
| created_at        | TIMESTAMP       | Creation timestamp                 |

### 3.2. `config_revision` Table

| Field             | Type            | Description                        |
|-------------------|-----------------|------------------------------------|
| id (PK)           | NUMBER          | Unique revision identifier         |
| config_id (FK)    | NUMBER          | Reference to `config` table        |
| revision          | NUMBER          | Revision number                    |
| json_data         | CLOB            | The JSON document                  |
| changed_by        | VARCHAR2(255)   | User who made the change           |
| changed_at        | TIMESTAMP       | Change timestamp                   |
| diff_summary      | CLOB (optional) | JSON diff summary (for UI display) |

**Indexes:**  
- `(config_id, revision DESC)` for quick access to latest revision.

---

## 4. **API Design**

### 4.1. **Endpoints**

- `POST /api/config/{name}`  
  - Stores a new revision if the JSON is changed.
- `GET /api/config/{id}/history`  
  - Returns a list of all revisions for a config.
- `GET /api/config/{id}/revision/{rev}`  
  - Returns a specific revision.

---

## 5. **Business Logic**

- On config update:
  - Fetch latest revision.
  - Compute diff between previous and new JSON (using a JSON diff library, e.g., zjsonpatch/Jackson).
  - Store new revision with diff summary and metadata (`changed_by`, `changed_at`).
  - Update `current_revision` in `config` table.
- On history query:
  - Return all revisions (with metadata and optional diffs) for auditing and UI display.
- On rollback:
  - User selects an old revision and re-applies it as a new revision via the same update endpoint.

---

## 6. **Change Tracking**

- **Diff Generation:**  
  Compute a machine-readable and human-readable diff of JSON changes for each revision.
- **Audit Trail:**  
  Store user and timestamp for every change.
- **Full Data Storage:**  
  Store the entire JSON in every revision to allow for easy rollback and auditing.

---

## 7. **Security and Integrity**

- Enforce unique config names.
- Use optimistic locking or versioning to avoid race conditions on concurrent updates.
- Validate JSON structure before storing.
- Ensure only authorized users can change configurations.

---

## 8. **Scalability and Maintenance**

- Archive/purge old revisions if storage becomes an issue.
- Consider sharding or partitioning tables for very large datasets.
- Monitor revision table growth and tune indexes as needed.

---

## 9. **Future Enhancements**

- Add UI for visual diff comparison and rollback.
- Support for comments/approval workflows on config changes.
- Notification system for config changes.
- Integration with external audit systems.

---

## 10. **Conclusion**

This design provides a robust, auditable, and user-friendly solution for storing and tracking JSON configuration changes, supporting both operational and compliance requirements.

---
