To maintain and display revision history of JSON configuration documents in a Java Spring Boot application using Oracle as the database, you need to design a system that tracks and stores changes over time. Hereâ€™s a step-by-step approach:

---

## 1. **Database Design**

### **Table for Configurations**

```sql
CREATE TABLE metric_config (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    config_name VARCHAR2(255) NOT NULL,
    current_revision NUMBER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Table for Revisions**

```sql
CREATE TABLE metric_config_revision (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_config_id NUMBER NOT NULL,
    revision_number NUMBER NOT NULL,
    config_json CLOB NOT NULL,
    changed_by VARCHAR2(255),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    change_summary CLOB,
    FOREIGN KEY (metric_config_id) REFERENCES metric_config(id)
);
-- Index for quick lookup
CREATE INDEX idx_metric_config_revision_config ON metric_config_revision(metric_config_id, revision_number DESC);
```

---

## 2. **Spring Boot Entity Models**

```java name=MetricConfig.java
@Entity
@Table(name = "metric_config")
public class MetricConfig {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String configName;
    private Integer currentRevision;
    private LocalDateTime createdAt;
    // getters and setters
}
```

```java name=MetricConfigRevision.java
@Entity
@Table(name = "metric_config_revision")
public class MetricConfigRevision {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "metric_config_id")
    private MetricConfig metricConfig;

    private Integer revisionNumber;

    @Lob
    private String configJson;

    private String changedBy;
    private LocalDateTime changedAt;

    @Lob
    private String changeSummary; // Optional: Store diff summary

    // getters and setters
}
```

---

## 3. **Repository Interfaces**

```java name=MetricConfigRepository.java
public interface MetricConfigRepository extends JpaRepository<MetricConfig, Long> {
    Optional<MetricConfig> findByConfigName(String configName);
}
```

```java name=MetricConfigRevisionRepository.java
public interface MetricConfigRevisionRepository extends JpaRepository<MetricConfigRevision, Long> {
    List<MetricConfigRevision> findByMetricConfigIdOrderByRevisionNumberDesc(Long metricConfigId);
}
```

---

## 4. **Service Logic**

- When a user updates the JSON config, fetch the last revision, compare the JSONs, and store the new revision with a diff summary.
- Store the full JSON (for audit), but also optionally compute a summary of changes (e.g., using a JSON diff library).

```java name=MetricConfigService.java
@Service
public class MetricConfigService {

    @Autowired
    private MetricConfigRepository configRepo;

    @Autowired
    private MetricConfigRevisionRepository revisionRepo;

    public void updateConfig(String configName, String newConfigJson, String changedBy) throws Exception {
        MetricConfig config = configRepo.findByConfigName(configName)
                .orElseGet(() -> {
                    MetricConfig nc = new MetricConfig();
                    nc.setConfigName(configName);
                    nc.setCurrentRevision(0);
                    nc.setCreatedAt(LocalDateTime.now());
                    return configRepo.save(nc);
                });

        // fetch current revision's JSON
        MetricConfigRevision lastRev = revisionRepo
            .findByMetricConfigIdOrderByRevisionNumberDesc(config.getId())
            .stream().findFirst().orElse(null);

        int nextRevision = (lastRev == null) ? 1 : lastRev.getRevisionNumber() + 1;
        String changeSummary = "";
        if (lastRev != null) {
            changeSummary = JsonDiffUtil.diff(lastRev.getConfigJson(), newConfigJson); // implement this!
        }

        MetricConfigRevision revision = new MetricConfigRevision();
        revision.setMetricConfig(config);
        revision.setRevisionNumber(nextRevision);
        revision.setConfigJson(newConfigJson);
        revision.setChangedBy(changedBy);
        revision.setChangedAt(LocalDateTime.now());
        revision.setChangeSummary(changeSummary);

        revisionRepo.save(revision);

        config.setCurrentRevision(nextRevision);
        configRepo.save(config);
    }

    public List<MetricConfigRevision> getRevisionHistory(Long configId) {
        return revisionRepo.findByMetricConfigIdOrderByRevisionNumberDesc(configId);
    }
}
```

---

## 5. **Comparing JSONs (Diff Summary)**

- Use a library like [Java JSON Patch](https://github.com/java-json-tools/json-patch) or [Jackson](https://github.com/FasterXML/jackson) to compare two JSONs and produce a summary.

```java name=JsonDiffUtil.java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.flipkart.zjsonpatch.JsonDiff;

public class JsonDiffUtil {
    private static final ObjectMapper mapper = new ObjectMapper();

    public static String diff(String oldJson, String newJson) throws Exception {
        JsonNode oldNode = mapper.readTree(oldJson);
        JsonNode newNode = mapper.readTree(newJson);
        JsonNode patch = JsonDiff.asJson(oldNode, newNode);
        return patch.toString(); // Or process to a more readable summary
    }
}
```

---

## 6. **Controller Endpoints**

- Create endpoints to update config and fetch revision history.

```java name=MetricConfigController.java
@RestController
@RequestMapping("/api/config")
public class MetricConfigController {

    @Autowired
    private MetricConfigService configService;

    @PostMapping("/{name}")
    public ResponseEntity<?> updateConfig(
            @PathVariable String name,
            @RequestBody String configJson,
            @RequestHeader("X-User") String user
    ) throws Exception {
        configService.updateConfig(name, configJson, user);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{id}/history")
    public List<MetricConfigRevision> getHistory(@PathVariable Long id) {
        return configService.getRevisionHistory(id);
    }
}
```

---

## 7. **UI Side**

- Display the list of revisions with who/when/what changed.
- Optionally show the diff summary for each revision (parsed from the `changeSummary` field).

---

## **Summary**

- Store each JSON config change as a new revision in a separate table.
- Store the diff summary between revisions for easy UI display.
- Fetch and display revision history from the DB.
- Use libraries to compute JSON diffs for audit trails.

Let me know if you need a full working sample or more details on any part!